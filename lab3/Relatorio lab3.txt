1)

Na letra A fiz um x & 0xFF pois assim mantenho o bit menos significativo  como os de x já que 1 é o elemento neutro do elemento do  AND

Na letra B fiz um x | 0x FF 00 00 00 assim mantenho coloco todos o do primeiro butes como 1 enquanto mantenho os mesmo valores que x tem no resto já que 0 é o elemento neutro do OR

@luangib ➜ /workspaces/inf1018/lab3 (main) $ ./ex1
00000021 ff654321

2)

O problema pede para verificar se um número inteiro sem sinal possui uma quantidade ímpar de bits 1 em sua representação binária. Para isso, não é permitido usar o operador %.

O raciocínio é simples:

Percorrer todos os 32 bits do número.

Em cada passo, usar x & 1 para verificar o bit menos significativo.

Se for 1, incrementa a contagem.

Deslocar x para a direita (x >> 1) e repetir até processar todos os bits.

Ao final, verificar apenas se a contagem é ímpar ou par, o que pode ser feito com count & 1.

Se for 1 → número ímpar de bits 1.

Se for 0 → número par de bits 1.

3)

(a)

A função switch_byte troca os dois nibbles de um byte.
Primeiro isola a parte alta com 0xF0 e desloca 4 bits para a direita.
Depois isola a parte baixa com 0x0F e desloca 4 bits para a esquerda.
Por fim, soma as duas partes e obtém o byte invertido (ex.: 0xAB → 0xBA).

(b)

(x << n) desloca x n bits para a esquerda. Os bits mais à esquerda “saem” do byte e normalmente seriam perdidos.

(x >> (8 - n)) desloca x para a direita, pegando justamente os bits que sairiam à esquerda e colocando-os na parte baixa do byte.

O | combina os dois resultados: os bits deslocados para a esquerda e os bits que voltaram da direita, formando o byte final com todos os bits corretamente rotacionados.